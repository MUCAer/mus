// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.13.
// **********************************************************************

#ifndef __UTILS_H_
#define __UTILS_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace inf
{
    struct TraceBlock : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "inf.TraceBlock";
        }
        static string MD5()
        {
            return "5c7d10467dd1dde8bd4c6b1ab1924c3a";
        }
        TraceBlock()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            logid = 0;
            upstream_ip = "";
            time_stamp = 0;
            service_name = "";
            status = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(logid, 0);
            _os.write(upstream_ip, 1);
            _os.write(time_stamp, 2);
            _os.write(service_name, 3);
            _os.write(status, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(logid, 0, true);
            _is.read(upstream_ip, 1, true);
            _is.read(time_stamp, 2, true);
            _is.read(service_name, 3, true);
            _is.read(status, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["logid"] = tars::JsonOutput::writeJson(logid);
            p->value["upstream_ip"] = tars::JsonOutput::writeJson(upstream_ip);
            p->value["time_stamp"] = tars::JsonOutput::writeJson(time_stamp);
            p->value["service_name"] = tars::JsonOutput::writeJson(service_name);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(logid,pObj->value["logid"], true);
            tars::JsonInput::readJson(upstream_ip,pObj->value["upstream_ip"], true);
            tars::JsonInput::readJson(time_stamp,pObj->value["time_stamp"], true);
            tars::JsonInput::readJson(service_name,pObj->value["service_name"], true);
            tars::JsonInput::readJson(status,pObj->value["status"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(logid,"logid");
            _ds.display(upstream_ip,"upstream_ip");
            _ds.display(time_stamp,"time_stamp");
            _ds.display(service_name,"service_name");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(logid, true);
            _ds.displaySimple(upstream_ip, true);
            _ds.displaySimple(time_stamp, true);
            _ds.displaySimple(service_name, true);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        tars::Int64 logid;
        std::string upstream_ip;
        tars::Int64 time_stamp;
        std::string service_name;
        std::string status;
    };
    inline bool operator==(const TraceBlock&l, const TraceBlock&r)
    {
        return l.logid == r.logid && l.upstream_ip == r.upstream_ip && l.time_stamp == r.time_stamp && l.service_name == r.service_name && l.status == r.status;
    }
    inline bool operator!=(const TraceBlock&l, const TraceBlock&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TraceBlock&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TraceBlock&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
